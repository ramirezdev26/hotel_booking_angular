# Lab05-04: Component Communication with @Input and @Output

## Overview
This document explains the implementation of Activity #4 - Component Communication using @Input and @Output decorators in the hotel booking system. The implementation demonstrates proper data flow between parent and child components, avoiding code duplication and maintaining a clean component architecture.

## Component Communication Architecture

### Parent-Child Communication Flow

```
HomeComponent (Parent)
    ↓ @Input (hotel data)
HotelCardComponent (Child)
    ↑ @Output (booking events)
HomeComponent (Parent)
```

## @Input Implementation

### HotelCardComponent - Child Component

**Location**: `src/app/shared/hotel-card/hotel-card.ts`

The HotelCardComponent receives data from its parent component through @Input decorators:

```typescript
export class HotelCardComponent {
  @Input() hotel!: Hotel;
  @Input() showBookButton: boolean = true;
  
  // ...component implementation
}
```

#### @Input Properties Detailed Analysis

1. **hotel: Hotel** (Required Input)
   - **Type**: Hotel interface
   - **Purpose**: Receives complete hotel data from parent component
   - **Usage**: Required property (using `!` operator)
   - **Data Structure**:
     ```typescript
     export interface Hotel {
       id: number;
       name: string;
       location: string;
       rating: number;
       imageUrl: string;
       description?: string;
       pricePerNight: number;
       amenities: string[];
     }
     ```

2. **showBookButton: boolean** (Optional Input)
   - **Type**: boolean
   - **Purpose**: Controls visibility of the "Book Now" button
   - **Default Value**: `true`
   - **Usage**: Allows parent component to conditionally show/hide booking functionality

#### Template Usage of @Input Properties

```html
<!-- hotel-card.html -->
<mat-card class="hotel-card">
  <img mat-card-image [src]="hotel.imageUrl" [alt]="hotel.name">
  
  <mat-card-header>
    <mat-card-title>{{ hotel.name }}</mat-card-title>
    <mat-card-subtitle>
      <mat-icon>location_on</mat-icon>
      {{ hotel.location }}
    </mat-card-subtitle>
  </mat-card-header>

  <mat-card-content>
    <p class="description">{{ hotel.description }}</p>
    
    <div class="amenities">
      @for (amenity of hotel.amenities.slice(0, 3); track amenity) {
        <mat-chip-option>{{ amenity }}</mat-chip-option>
      }
    </div>

    <div class="price-section">
      <span class="price">${{ hotel.pricePerNight }}</span>
      <span class="price-label">per night</span>
    </div>
  </mat-card-content>

  <mat-card-actions>
    @if (showBookButton) {
      <button mat-raised-button (click)="onBookHotel()">
        Book Now
      </button>
    }
  </mat-card-actions>
</mat-card>
```

## @Output Implementation

### Event Emission from Child to Parent

The HotelCardComponent communicates back to its parent through @Output decorators:

```typescript
export class HotelCardComponent {
  @Output() bookHotel = new EventEmitter<number>();

  onBookHotel() {
    this.bookHotel.emit(this.hotel.id);
  }
}
```

#### @Output Properties Detailed Analysis

1. **bookHotel: EventEmitter<number>**
   - **Type**: EventEmitter that emits number values
   - **Purpose**: Notifies parent component when user clicks "Book Now"
   - **Emitted Data**: Hotel ID (number)
   - **Trigger**: User clicks the "Book Now" button

#### Event Emission Logic

```typescript
onBookHotel() {
  this.bookHotel.emit(this.hotel.id);
}
```

**Flow**:
1. User clicks "Book Now" button in template
2. `(click)="onBookHotel()"` triggers the method
3. Method emits hotel ID through `bookHotel` EventEmitter
4. Parent component receives the event and hotel ID

## Parent Component Implementation

### HomeComponent - Parent Component

**Location**: `src/app/pages/home/home.ts`

The HomeComponent acts as the parent, providing data through @Input and handling events through @Output:

```typescript
export class HomeComponent implements OnInit {
  hotels: Hotel[] = [];

  ngOnInit() {
    this.loadMockHotels();
  }

  onHotelBooked(hotelId: number) {
    console.log(`Booking hotel with ID: ${hotelId}`);
    // Here you would typically navigate to booking page or open booking modal
  }

  private loadMockHotels() {
    this.hotels = [
      {
        id: 1,
        name: 'Grand Plaza Hotel',
        location: 'New York City, NY',
        rating: 4.5,
        imageUrl: 'https://images.unsplash.com/photo-1566073771259-6a8506099945?w=400&h=300&fit=crop',
        description: 'Luxury hotel in the heart of Manhattan with stunning city views.',
        pricePerNight: 299,
        amenities: ['WiFi', 'Pool', 'Gym', 'Spa', 'Restaurant']
      },
      // ... more hotel data
    ];
  }
}
```

### Template Implementation in Parent

```html
<!-- home.html -->
<div class="hotels-grid">
  @for (hotel of hotels; track hotel.id) {
    <app-hotel-card 
      [hotel]="hotel" 
      [showBookButton]="true"
      (bookHotel)="onHotelBooked($event)">
    </app-hotel-card>
  }
</div>
```

#### Data Binding Analysis

1. **Property Binding (Input)**:
   - `[hotel]="hotel"` - Passes hotel object from parent's hotels array
   - `[showBookButton]="true"` - Explicitly enables the booking button

2. **Event Binding (Output)**:
   - `(bookHotel)="onHotelBooked($event)"` - Listens for booking events
   - `$event` contains the emitted hotel ID

## Component Communication Benefits

### 1. Code Reusability

**Before @Input/@Output**:
```typescript
// Would need separate components for each use case
HotelCardWithBooking
HotelCardWithoutBooking
HotelCardReadOnly
```

**With @Input/@Output**:
```typescript
// Single reusable component
<app-hotel-card [hotel]="hotel" [showBookButton]="false">
<app-hotel-card [hotel]="hotel" [showBookButton]="true">
```

### 2. Data Flow Control

- **Unidirectional Data Flow**: Parent controls child state through @Input
- **Event-Driven Communication**: Child notifies parent through @Output
- **Separation of Concerns**: Each component has clear responsibilities

### 3. Flexibility and Maintainability

```typescript
// Easy to modify behavior from parent
<app-hotel-card 
  [hotel]="hotel" 
  [showBookButton]="userCanBook && !hotel.fullyBooked"
  (bookHotel)="handleBooking($event)">
```

## Real-World Usage Examples

### Example 1: Conditional Button Display

```html
<!-- Show booking button only for available hotels -->
<app-hotel-card 
  [hotel]="hotel" 
  [showBookButton]="hotel.available && userLoggedIn"
  (bookHotel)="onHotelBooked($event)">
```

### Example 2: Different Event Handlers

```html
<!-- Different pages can handle booking differently -->

<!-- Home Page: Navigate to details -->
<app-hotel-card 
  (bookHotel)="navigateToHotelDetails($event)">

<!-- Search Results: Add to favorites -->
<app-hotel-card 
  (bookHotel)="addToFavorites($event)">

<!-- Booking Page: Direct booking -->
<app-hotel-card 
  (bookHotel)="openBookingModal($event)">
```

## Data Validation and Type Safety

### Interface Definition

```typescript
export interface Hotel {
  id: number;                    // Required: Unique identifier
  name: string;                  // Required: Hotel name
  location: string;              // Required: Hotel location
  rating: number;                // Required: Rating (0-5)
  imageUrl: string;              // Required: Hotel image URL
  description?: string;          // Optional: Hotel description
  pricePerNight: number;         // Required: Price per night
  amenities: string[];           // Required: List of amenities
}
```

### Type Safety Benefits

1. **Compile-time Checking**: TypeScript validates property types
2. **IDE Support**: Auto-completion and error detection
3. **Runtime Safety**: Prevents undefined property access
4. **Documentation**: Interface serves as component contract

## Event Handling Patterns

### Current Implementation

```typescript
// Child Component
onBookHotel() {
  this.bookHotel.emit(this.hotel.id);
}

// Parent Component
onHotelBooked(hotelId: number) {
  console.log(`Booking hotel with ID: ${hotelId}`);
}
```

### Enhanced Event Handling (Future Extensions)

```typescript
// Could emit more detailed event data
export interface BookingEvent {
  hotelId: number;
  action: 'book' | 'favorite' | 'share';
  timestamp: Date;
}

@Output() hotelAction = new EventEmitter<BookingEvent>();

onBookHotel() {
  this.hotelAction.emit({
    hotelId: this.hotel.id,
    action: 'book',
    timestamp: new Date()
  });
}
```

## Performance Considerations

### Change Detection Optimization

1. **OnPush Strategy**: Can be implemented for better performance
2. **TrackBy Functions**: Used in template (`track hotel.id`)
3. **Immutable Data**: Ensures proper change detection

### Memory Management

- **EventEmitter Cleanup**: Automatically handled by Angular
- **Subscription Management**: Not needed for template event bindings
- **Component Lifecycle**: Proper cleanup in ngOnDestroy if needed

## Best Practices Implemented

### 1. Clear Component Contracts

```typescript
// Clear input/output interface
@Input() hotel!: Hotel;              // Required data
@Input() showBookButton = true;      // Optional configuration
@Output() bookHotel = new EventEmitter<number>(); // Event communication
```

### 2. Meaningful Event Names

- `bookHotel` - Clear action intent
- Emits relevant data (hotel ID)
- Follows Angular naming conventions

### 3. Template Binding Patterns

```html
<!-- Property binding with square brackets -->
[hotel]="hotelData"

<!-- Event binding with parentheses -->
(bookHotel)="handleBooking($event)"

<!-- Two-way binding (if needed) -->
[(property)]="value"
```

## Testing Considerations

### Unit Testing @Input/@Output

```typescript
// Example test structure
describe('HotelCardComponent', () => {
  it('should emit hotel ID when booking button is clicked', () => {
    // Arrange
    component.hotel = mockHotel;
    spyOn(component.bookHotel, 'emit');
    
    // Act
    component.onBookHotel();
    
    // Assert
    expect(component.bookHotel.emit).toHaveBeenCalledWith(mockHotel.id);
  });
});
```

## Summary

The implementation demonstrates excellent use of Angular's component communication patterns:

✅ **@Input Properties**: Clean data flow from parent to child  
✅ **@Output Events**: Proper event emission from child to parent  
✅ **Type Safety**: Strong typing with TypeScript interfaces  
✅ **Reusability**: Single component used in multiple contexts  
✅ **Maintainability**: Clear separation of concerns  
✅ **Flexibility**: Configurable behavior through inputs  
✅ **Best Practices**: Following Angular conventions and patterns  

The HotelCardComponent serves as an excellent example of a reusable, well-architected Angular component that properly implements component communication patterns while maintaining clean code and avoiding duplication.
